# 复习
## go 中的 注意点
- go跨平台编译
- go中数组是值类型.
```go
b1 := [3]int{1,2,3}
b2 := b1
b2[0] = 100
fmt.Println(b1,b2)
// b1: [1 2 3]
// b2: [100 2 3]
```
- 数组支持"==","!="操作符.
- [n]*T 表示指针数组,\*[n]T表示数组指针.
- 空指针问题
```go
var a *int // a = nil
*a = 100
fmt.Println(*a)
// 代码报错.不能对空指针取地址.

// 正确代码
a1 := new(int)
*a1 = 100
fmt.Println(*a1)
```
- go中的映射容器为map,其内部使用散列表(hash)实现.
- defer执行时机
**在Go语言的函数中return语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而defer语句执行的时机就在返回值赋值操作后，RET指令执行前。** 具体如下图所示：
![](assets/defer.png)

- 占位符
    - %%: 打印%
    - %t: 打印布尔值
    - %q: 打印像'a'的字符.或者打印像"adaa"的字符串.
    - %08q: 
    ```go
   fmt.Printf("%08b\n", 1) //打印00000001
    ```
    - %9.2f: 宽度9,精度2
    - %5.f:宽度5,精度0
    - %.2f:默认宽度,精度2
    - %9f: 宽度9,默认精度.

- go 中结构体是值类型的.
- go 中结构体是占用一块连续的内存，一个结构体变量的大小是由结构体中的字段决定。
- go 中的内存对齐?
- go 中方法是作用于特定类型的函数.这个特定类型叫做接收者.
- go 中结构体的匿名字段.
```go
type people struct{
    string
    int
}
```
- go 中匿名嵌套结构体.匿名嵌套结构体可能存在字段冲突.
```go
type addr struct {
    name string
    city string
}
type people struct {
    name string
    age int
    addr //匿名嵌套结构体
}
func main(){
    p := new(people)
    fmt.Println(p.city) //通过匿名嵌套结构体,可以直接p.city
}
```
- go 中也可以通过嵌套结构体实现类型继承的效果.
- go 结构体与JSON.
- go 中接口是一种类型. 
- go 中指针接收者实现接口与值接收者实现接口的区别?
    - 使用值接收者实现接口之后，不管是结构体类型还是对应的结构体指针类型的变量都可以赋值给该接口变量。
    - 使用指针接收者实现接口之后，只能将结构体指针类型的变量赋值给该接口变量。
- 由于Go语言中有对指针求值的语法糖，对于值接收者实现的接口，无论使用值类型还是指针类型都没有问题。但是我们并不总是能对v一个值求址，所以对于指针接收者实现的接口要额外注意。
- go 中的空接口类型
- 多个包中init函数的执行顺序
![](assets/package01.png)

- 串行
- 并发
- 并行
- goroutine :用户态线程,运行时调度和管理.而线程是由操作系统调度和管理.
    - 进程（process）：程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。
    - 线程（thread）：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位。
    - 协程（coroutine）：非操作系统提供而是由用户自行创建和控制的用户态‘线程’，比线程更轻量级。
- channel: 通过channel在多个goroutine间进行通信.
- CSP并发模式.
- 动态栈
```
操作系统的线程一般都有固定的栈内存（通常为2MB）,而 Go 语言中的 goroutine 非常轻量级，一个 goroutine 的初始栈空间很小（一般为2KB），所以在 Go 语言中一次创建数万个 goroutine 也是可能的。并且 goroutine 的栈不是固定的，可以根据需要动态地增大或缩小， Go 的 runtime 会自动为 goroutine 分配合适的栈空间。
```  
- GMP调度模型
