/*
 * @Author: zwngkey
 * @Date: 2022-04-30 23:38:23
 * @LastEditTime: 2022-05-11 23:25:18
 * @Description:
 */
package godefer

import (
	"fmt"
	"sync"
	"testing"
)

/*
	延迟函数调用（deferred function call）
		在Go中，一个函数调用可以跟在一个defer关键字后面，形成一个延迟函数调用。
			和协程调用类似，被延迟的函数调用的所有返回值必须全部被舍弃。

		当一个函数调用被延迟后，它不会立即被执行。它将被推入由当前协程维护的一个延迟调用堆栈。
		 当一个函数调用（可能是也可能不是一个延迟调用）返回并进入它的退出阶段后，
		 所有在此函数调用中已经被推入的延迟调用将被按照它们被推入堆栈的顺序逆序执行。
		 当所有这些延迟调用执行完毕后，此函数调用也就真正退出了。

		事实上，每个协程维护着两个调用堆栈。
			一个是正常的函数调用堆栈。在此堆栈中，相邻的两个调用存在着调用关系。
				晚进入堆栈的调用被早进入堆栈的调用所调用。 此堆栈中最早被推入的调用是对应协程的启动调用。

			另一个堆栈是上面提到的延迟调用堆栈。处于延迟调用堆栈中的任意两个调用之间不存在调用关系。

	延迟函数调用的必要性和好处
		defer常用于成对的操作，比如文件打开后要关闭、锁的申请和释放、sync.WaitGroup跟踪的goroutine的计数器的释放等。
			为了确保资源被释放，可以结合defer一起使用，避免在代码的各种条件分支里去释放资源，容易遗漏和出错。


	协程和延迟调用的实参的估值时刻
		一个协程调用或者延迟调用的实参是在此调用发生时被估值的。更具体地说，
			对于一个延迟函数调用，它的实参是在此调用被推入延迟调用堆栈的时候被估值的。
			对于一个协程调用，它的实参是在此协程被创建的时候估值的。

		一个匿名函数体内的表达式是在此函数被执行的时候才会被逐个估值的，不管此函数是被普通调用还是延迟/协程调用。

	注意：如果是函数是因为调用了os.Exit()而退出，那defer就不会被执行了。
*/

// 被defer的函数可以对defer语句所在的函数的命名返回值做读取和修改操作。
//	执行顺序是函数先把要返回的值赋值给 命名返回值变量r，然后执行被defer的函数func，r 被修改,然后函数f返回r.
func fc1(n int) (r int) {
	defer func() {
		r += n // 修改返回值
	}()
	return n + n // <=> r = n + n; return
}

func Test1(t *testing.T) {
	fmt.Println(fc1(5)) // 15
}

// defer结合goroutine和闭包一起使用，可以让任务函数内部不用关心Go并发里的同步原语
func worker(id int) {
	fmt.Println(id)
}

func Test2(t *testing.T) {

	var wg sync.WaitGroup
	size := 10
	wg.Add(size)

	for i := 0; i < size; i++ {
		i := i
		/*
		  把worker的调用和defer放在一个闭包里
		  这样worker函数内部就不用使用WaitGroup了
		*/
		go func() {
			defer wg.Done()
			worker(i)
		}()
	}

	wg.Wait()
}
