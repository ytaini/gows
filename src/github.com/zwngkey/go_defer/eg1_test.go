/*
 * @Author: zwngkey
 * @Date: 2022-04-30 23:38:23
 * @LastEditTime: 2022-05-01 00:12:32
 * @Description:
 */
package godefer

import (
	"fmt"
	"testing"
)

/*
	延迟函数调用（deferred function call）
		在Go中，一个函数调用可以跟在一个defer关键字后面，形成一个延迟函数调用。
			和协程调用类似，被延迟的函数调用的所有返回值必须全部被舍弃。

		当一个函数调用被延迟后，它不会立即被执行。它将被推入由当前协程维护的一个延迟调用堆栈。
		 当一个函数调用（可能是也可能不是一个延迟调用）返回并进入它的退出阶段后，
		 所有在此函数调用中已经被推入的延迟调用将被按照它们被推入堆栈的顺序逆序执行。
		 当所有这些延迟调用执行完毕后，此函数调用也就真正退出了。

		事实上，每个协程维护着两个调用堆栈。
			一个是正常的函数调用堆栈。在此堆栈中，相邻的两个调用存在着调用关系。
				晚进入堆栈的调用被早进入堆栈的调用所调用。 此堆栈中最早被推入的调用是对应协程的启动调用。

			另一个堆栈是上面提到的延迟调用堆栈。处于延迟调用堆栈中的任意两个调用之间不存在调用关系。

	延迟函数调用的必要性和好处

	协程和延迟调用的实参的估值时刻
		一个协程调用或者延迟调用的实参是在此调用发生时被估值的。更具体地说，
			对于一个延迟函数调用，它的实参是在此调用被推入延迟调用堆栈的时候被估值的。
			对于一个协程调用，它的实参是在此协程被创建的时候估值的。

		一个匿名函数体内的表达式是在此函数被执行的时候才会被逐个估值的，不管此函数是被普通调用还是延迟/协程调用。

*/

// 一个延迟调用可以修改包含此延迟调用的最内层函数的返回值
func fc1(n int) (r int) {
	defer func() {
		r += n // 修改返回值
	}()
	return n + n // <=> r = n + n; return
}

func Test1(t *testing.T) {
	fmt.Println(fc1(5)) // 15
}

/*
	恐慌（panic）和恢复（recover）
		Go不支持异常抛出和捕获，而是推荐使用返回值显式返回错误。
			不过，Go支持一套和异常抛出/捕获类似的机制。此机制称为恐慌/恢复（panic/recover）机制。

		可以调用内置函数panic来产生一个恐慌以使当前协程进入恐慌状况

		进入恐慌状况是另一种使当前函数调用开始返回的途径。 一旦一个函数调用产生一个恐慌，
			此函数调用将立即进入它的退出阶段，在此函数调用中被推入堆栈的延迟调用将按照它们被推入的顺序逆序执行。

		通过在一个延迟函数调用之中调用内置函数recover，当前协程中的一个恐慌可以被消除，从而使得当前协程重新进入正常状况。

		在一个处于恐慌状况的协程退出之前，其中的恐慌不会蔓延到其它协程。 如果一个协程在恐慌状况下退出，它将使整个程序崩溃。

		内置函数panic和recover的声明原型如下：
			func panic(v interface{})
			func recover() interface{}

		recover函数的返回值为其所恢复的恐慌的参数值.

		一般说来，恐慌用来表示正常情况下不应该发生的逻辑错误。
			如果这样的一个错误在运行时刻发生了，则它肯定是由于某个bug引起的。
			另一方面，非逻辑错误是现实中难以避免的错误，它们不应该导致恐慌。 我们必须正确地对待和处理非逻辑错误。

		一些致命性错误不属于恐慌
			对于官方标准编译器来说，很多致命性错误（比如堆栈溢出和内存不足）不能被恢复。它们一旦产生，程序将崩溃。



*/
