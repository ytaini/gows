package greedy

import (
	"sort"
)

//g:对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；
//s:每块饼干 j，都有一个尺寸 s[j]
func FindContentChildren(g, s []int) int {
	// 为了尽可能满足最多数量的孩子，从贪心的角度考虑，
	// 应该按照孩子的胃口从小到大的顺序依次满足每个孩子，
	// 且对于每个孩子，应该选择可以满足这个孩子的胃口且尺寸最小的饼干

	//排序?
	// 为了满足尽可能多的孩子，所以选择：优先满足胃口小的孩子（比较容易被满足）。所以才进行排序

	//贪心策略是：
	// 如果某个饼干不能满足该孩子，一定不能满足需求因子更大的孩子；
	// 如果能用更小的饼干满足该孩子，则没必要用更大的；
	// 需求因子小的孩子更容易被满足，故应从小到大开始分配。
	sort.Ints(g)
	sort.Ints(s)

	//[3,6,8,10]
	//[2,4,5,6,7]

	gn := len(g)
	sn := len(s)

	//胃口值g的指针
	i := 0
	//饼干尺寸s的指针
	j := 0

	for i < gn && j < sn {
		// 用饼干 j满足了孩子 i
		if g[i] <= s[j] {
			//i 可代表已有几个孩子满足了胃口.
			//i,j都需要更新
			i++
		}
		// 否则，如果饼干j无法满足孩子 i ，那么总认为是饼干的问题（于是用下一块更大的饼干，看看能否满足这个孩子）
		// 而不是换下一个孩子（因为当前胃口小的孩子都无法满足，那么下一个胃口更大的孩子更不可能满足了）
		j++
	}

	return i
}
