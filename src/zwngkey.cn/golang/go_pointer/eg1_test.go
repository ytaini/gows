/*
 * @Author: zwngkey
 * @Date: 2022-05-01 14:09:56
 * @LastEditTime: 2022-05-02 13:49:01
 * @Description: go的指针
 */
package gopointer

import (
	"fmt"
	"testing"
)

/*
	虽然Go吸收融合了很多其语言中的各种特性，但是Go主要被归入C语言家族。
		其中一个重要的原因就是Go和C一样，也支持指针。 当然Go中的指针相比C指针有很多限制。

	内存地址:
		1.在编程中，一个内存地址用来定位一段内存。
		2.通常地，一个内存地址用一个操作系统原生字（native word）来存储。
			一个原生字在32位操作系统上占4个字节，在64位操作系统上占8个字节。
			所以，32位操作系统上的理论最大支持内存容量为4GB（1GB == 2^30字节），
			64位操作系统上的理论最大支持内存容量为2^64Byte，即16EB（EB：艾字节，1EB == 1024PB, 1PB == 1024TB, 1TB == 1024GB）。
		3.内存地址的字面形式常用整数的十六进制字面量来表示，比如0x1234CDEF。
		4.以后我们常简称内存地址为地址。

	值的地址
		一个值的地址是指此值的直接部分占据的内存的起始地址。

	什么是指针？
		指针是Go中的一种类型分类（kind）。 一个指针可以存储一个内存地址；存的地址通常为另外一个值的地址。
			和C指针不一样，为了安全起见，Go指针有很多限制

	指针类型和值
		在Go中，一个非定义指针类型的字面形式为*T，其中T为一个任意类型。类型T 称为 指针类型*T 的基类型（base type）。
		 如果一个指针类型的基类型为T，则我们可以称此指针类型为一个T指针类型。

		虽然我们可以声明定义指针类型，但是一般不推荐这么做。非定义指针类型的可读性更高。

		如果一个指针类型的底层类型是*T，则它的基类型为T。
		 如果两个非定义指针类型的基类型为同一类型，则这两个非定义指针类型亦为同一类型。

		一些指针类型的例子：
			*int  // 一个基类型为int的非定义指针类型。
			**int // 一个多级非定义指针类型，它的基类型为*int。

			type Ptr *int // Ptr是一个定义的指针类型，它的基类型为int。
			type PP *Ptr  // PP是一个定义的多级指针类型，它的基类型为Ptr。
		指针类型的零值的字面量使用预声明的nil来表示。一个nil指针（常称为空指针）中不存储任何地址。

		如果一个指针类型的基类型为T，则此指针类型的值只能存储类型为T的值的地址。


	引用（reference）
		如果一个指针中存储着另外一个值的地址，则我们可以说此指针值引用着另外一个值；同时另外一个值当前至少有一个引用。
		当一个指针引用着另外一个值，我们也常说此指针指向另外一个值。


	如何获取一个指针值？
		有两种方式来得到一个指针值：
			我们可以用内置函数new来为任何类型的值开辟一块内存并将此内存块的起始地址做为此值的地址返回。
				 假设T是任一类型，则函数调用new(T)返回一个类型为*T的指针值。
				  存储在返回指针值所表示的地址处的值（可被看作是一个匿名变量）为T的零值。

			我们也可以使用前置取地址操作符&来获取一个可寻址的值的地址。
			 对于一个类型为T的可寻址的值t，我们可以用&t来取得它的地址。&t的类型为*T。


		当一个变量被声明的时候，Go运行时将为此变量开辟一段内存。此内存的起始地址即为此变量的地址。

		一般说来，一个可寻址的值是指被放置在内存中某固定位置处的一个值（但放置在某固定位置处的一个值并非一定是可寻址的）。
		 目前，我们只需知道所有变量都是可以寻址的；但是所有常量、函数返回值和强制转换结果都是不可寻址的。


	指针（地址）解引用
		我们可以使用前置解引用操作符*来访问存储在一个指针所表示的地址处的值（即此指针所引用着的值）。
			比如，对于基类型为T的指针类型的一个指针值p，我们可以用*p来表示地址p处的值。 此值的类型为T。
			*p称为指针p的解引用。解引用是取地址的逆过程。

		解引用一个nil指针将产生一个恐慌。
*/
//如何取地址和解引用。
func Test3(t *testing.T) {
	p0 := new(int)   // p0指向一个int类型的零值
	fmt.Println(p0)  // （打印出一个十六进制形式的地址）
	fmt.Println(*p0) // 0

	x := *p0         // x是p0所引用的值的一个复制。
	p1, p2 := &x, &x // p1和p2中都存储着x的地址。
	// x、*p1和*p2表示着同一个int值。
	fmt.Println(p1 == p2) // true
	fmt.Println(p0 == p1) // false
	p3 := &*p0            // <=> p3 := &(*p0)
	// <=> p3 := p0
	// p3和p0中存储的地址是一样的。
	fmt.Println(p0 == p3) // true
	*p0, *p1 = 123, 789
	fmt.Println(*p2, x, *p3) // 789 789 123

	fmt.Printf("%T, %T \n", *p0, x) // int, int
	fmt.Printf("%T, %T \n", p0, p1) // *int, *int

}

/*
	为什么需要指针？
		在Go中，所有的赋值（包括函数调用传参）过程都是一个值复制过程。
			 所以在下面的double函数体内修改的是变量a的一个副本，而没有修改变量a本身。

		将double函数的输入参数的类型改为*int，传入的实参&a和它在此函数体内的一个副本x都引用着变量a。
			所以对*x的修改等价于对*p（也就是变量a）的修改。 换句话说，新版本的double函数内的操作可以反映到此函数外了。

		简而言之，指针提供了一种间接的途径来访问和修改一些值。
			虽然很多语言中没有指针这个概念，但是指针被隐藏其它概念之中。

*/
func double(x *int) {
	*x += *x
}

// func double(x int) {
// 	x += x
// }
func Test4(t *testing.T) {
	var a = 3
	double(&a)
	fmt.Println(a)
}

/*
	在Go中返回一个局部变量的地址是安全的
		和C不一样，Go是支持垃圾回收的，所以一个函数返回其内声明的局部变量的地址是绝对安全的。
*/
//比如：
func NewInt() *int {
	a := 3
	return &a
}

/*

	Go指针的一些限制
		为了安全起见，Go指针在使用上相对于C指针有很多限制。
		 通过施加这些限制，Go指针保留了C指针的好处，同时也避免了C指针的危险性。

		Go指针不支持算术运算
			在Go中，指针是不能参与算术运算的。比如，对于一个指针p， 运算p++和p-2都是非法的。
			如果p为一个指向一个数值类型值的指针，*p++将被编译器认为是合法的并且等价于(*p)++。
			换句话说，解引用操作符*的优先级都高于自增++和自减--操作符。

*/
func Test11(t *testing.T) {
	a := int64(5)
	p := &a

	// 下面这两行编译不通过。
	/*
		p++
		p = (&a) + 8
	*/
	*p++
	fmt.Println(*p, a)   // 6 6
	fmt.Println(p == &a) // true

	(*(&a))++
	*&*&a++
	**&p++
	*&*p++
	fmt.Println(*p, a) // 10 10

}

/*
	一个指针类型的值不能被随意转换为另一个指针类型

		在Go中，只有如下某个条件被满足的情况下，一个类型为T1的指针值才能被显式转换为另一个指针类型T2：
			类型T1和T2的底层类型必须一致（忽略结构体字段的标签）。
				 特别地，如果类型T1和T2中只要有一个是非定义类型并且它们的底层类型一致（考虑结构体字段的标签），
				 则此转换可以是隐式的。

			类型T1和T2都为非定义类型并且它们的基类型的底层类型一致（忽略结构体字段的标签）。

		比如，
			type MyInt int64
			type Ta    *int64
			type Tb    *MyInt
		对于上面所示的这些指针类型，下面的事实成立：
			类型 *int64的值可以被隐式转换到类型Ta，反之亦然（因为它们的底层类型均为*int64）。
			类型 *MyInt的值可以被隐式转换到类型Tb，反之亦然（因为它们的底层类型均为*MyInt）。
			类型 *MyInt的值可以被显式转换为类型*int64，反之亦然（因为它们都是非定义的并且它们的基类型的底层类型均为int64）。
			类型Ta的值不能直接被转换为类型Tb，即使是显式转换也是不行的。
			  但是，通过上述三条事实，通过三层显式转换Tb((*MyInt)((*int64)(ta)))，一个类型为Ta的值ta可以被间接地转换为类型Tb。

		这些指针类型的任何值都无法被转换到类型*uint64。

*/
type MyInt64 int64
type Ta *int64
type Tb *MyInt64

func Test5(t *testing.T) {
	var a *int64 = new(int64)

	// *int64 与 Ta 的底层类型都为*int64
	//*int64的值a可以被隐式转换为Ta类型.
	var b Ta = a
	//Ta类型的值b可以被隐式转换为*int64
	a = b
	fmt.Println(a == b)

	//*MyInt64 与 Tb 的底层类型都为*MyInt64
	//*MyInt64的值c可以被隐式转换为Tb类型
	var c *MyInt64 = new(MyInt64)
	var d Tb = c
	//Tb类型的值c可以被隐式转换为*MyInt64类型
	c = d
	fmt.Println(c == d)

	// fmt.Println(a == c)
	//*MyInt的值可以被显式转换为类型*int64
	a = (*int64)(c)
	_ = a

	// Tb 转 Ta, 不能直接转,能间接转.
	//Tb 先转 *MyInt64 ,再转 * int64
	b = (*int64)((*MyInt64)(d))
}

/*
	一个指针值不能和其它任一指针类型的值进行比较
		Go指针值是支持（使用比较运算符==和!=）比较的。 但是，两个指针只有在下列任一条件被满足的时候才可以比较：
			1.这两个指针的类型相同。
			2.其中一个指针可以被隐式转换为另一个指针的类型。
				换句话说，这两个指针的类型的底层类型必须一致并且其中一个指针类型为非定义的（考虑结构体字段的标签）。
			3.其中一个并且只有一个指针用类型不确定的nil标识符表示。

*/
func Test6(t *testing.T) {
	type MyInt int64
	type Ta *int64
	type Tb *MyInt

	// 4个不同类型的指针：
	var pa0 Ta
	var pa1 *int64
	var pb0 Tb
	var pb1 *MyInt

	// 下面这6行编译没问题。它们的比较结果都为true。
	_ = pa0 == pa1
	_ = pb0 == pb1
	_ = pa0 == nil
	_ = pa1 == nil
	_ = pb0 == nil
	_ = pb1 == nil

	// 下面这三行编译不通过。
	/*
		_ = pa0 == pb0
		_ = pa1 == pb1
		_ = pa0 == Tb(nil)
	*/
}

/*
	一个指针值不能被赋值给其它任意类型的指针值
		一个指针值可以被赋值给另一个指针值的条件和这两个指针值可以比较的条件是一致的。


	上述Go指针的限制是可以被打破的
		unsafe标准库包中提供的非类型安全指针（unsafe.Pointer）机制可以被用来打破上述Go指针的安全限制。
			unsafe.Pointer类型类似于C语言中的void*。 但是，通常地，非类型安全指针机制不推荐在Go日常编程中使用。

*/
