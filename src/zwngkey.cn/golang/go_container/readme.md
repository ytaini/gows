# 切片的内部结构

官方标准编译器对切片类型的内部定义大致如下：

```go
type _slice struct {
	elements unsafe.Pointer // 引用着底层存储在间接部分上的元素
	len      int            // 长度
	cap      int            // 容量
}
```

虽然其它编译器中切片类型的内部结构可能并不完全和官方标准编译器一致，但应该大体上是相似的。 下面的解释均基于官方标准编译器对切片类型的内部定义。

**上面展示的切片的内部定义为切片的直接部分的定义**。直接部分的`len`字段表示一个切片当前存储了多少个元素；直接部分的`cap`表示一个切片的容量。 下面这张图描绘了一个切片值的内存布局。

![](/Users/zhangwei/Pictures/mdpic/slice-internal.png)

>尽管一个切片值的底层元素部分可能位于一个比较大的内存片段上，但是此切片值只能感知到此内存片段上的一个子片段。 比如，上图中的切片值只能感知到灰色的子片段。
>
>在上图中，从下标`len`（包含）到下标`cap`（不包含）对应的元素并不属于图中所示的切片值。 它们只是此切片之中的一些冗余元素槽位，但是它们可能是其它切片（或者数组）值中的有效元素。

调用内置`append`函数来向一个基础切片添加元素而得到一个新的切片。 这个新的结果切片可能和这个基础切片共享起始元素，也可能不共享，具体取决于基础切片的容量（以及长度）和添加的元素数量。

当一个切片被用做一个`append`函数调用中的基础切片，

- 如果添加的元素数量大于此（基础）切片的冗余元素槽位的数量，则一个新的底层内存片段将被开辟出来并用来存放结果切片的元素。 这时，基础切片和结果切片不共享任何底层元素。
- 否则，不会有底层内存片段被开辟出来。这时，基础切片中的所有元素也同时属于结果切片。两个切片的元素都存放于同一个内存片段上。

一些其它切片操作也可能会造成两个切片共享底层内存片段的情况。

*注意，一般我们不能单独修改一个切片值的某个内部字段，除非使用[反射](https://gfw.go101.org/article/container.html#modify-slice-length-and-capacity)或者[非类型安全指针](https://gfw.go101.org/article/unsafe.html)。 换句话说，一般我们只能通过将其它切片赋值给一个切片来同时修改这个切片的三个字段。*





```go
func main() {
	s0 := []int{2, 3, 5}
	fmt.Println(s0, cap(s0)) // [2 3 5] 3
	s1 := append(s0, 7)      // 添加一个元素
	fmt.Println(s1, cap(s1)) // [2 3 5 7] 6
	s2 := append(s1, 11, 13) // 添加两个元素
	fmt.Println(s2, cap(s2)) // [2 3 5 7 11 13] 6
	s3 := append(s0)         // <=> s3 := s0
	fmt.Println(s3, cap(s3)) // [2 3 5] 3
	s4 := append(s0, s0...)  // 以s0为基础添加s0中所有的元素
	fmt.Println(s4, cap(s4)) // [2 3 5 2 3 5] 6

	s0[0], s1[0] = 99, 789
	fmt.Println(s2[0], s3[0], s4[0]) // 789 99 2
}
```

在上面的程序中，

- 第*4*行的`append`函数调用将为结果切片`s1`开辟一段新的内存。 原因是切片`s0`中没有足够的冗余元素槽位来容纳新添加的元素。 第*10*行的`append`函数调用也是同样的情况。
- 第6行的`append`函数调用不会为结果切片`s2`开辟新的内存片段。 原因是切片`s1`中的冗余元素槽位足够容纳新添加的元素。

 下面这张图描绘了在上面的程序结束之前各个切片的状态。

![](/Users/zhangwei/Pictures/mdpic/slice-append.png)

请注意，当一个`append`函数调用需要为结果切片开辟内存时，结果切片的容量取决于具体编译器实现。 在这种情况下，对于官方标准编译器，如果基础切片的容量较小，则结果切片的容量至少为基础切片的两倍。 这样做的目的是使结果切片有足够多的冗余元素槽位，以防止此结果切片被用做后续其它`append`函数调用的基础切片时再次开辟内存。



`append`函数调用的第一个实参不能为类型不确定的`nil`。可以为类型确定的`nil`.如下面的代码:

```go
func f1(){
		s := append([]string(nil),"string","int")
}
```







```go
使用了子切片语法的例子：
package main

import "fmt"

func main() {
	a := [...]int{0, 1, 2, 3, 4, 5, 6}
	s0 := a[:]     // <=> s0 := a[0:7:7]
	s1 := s0[:]    // <=> s1 := s0
	s2 := s1[1:3]  // <=> s2 := a[1:3]
	s3 := s1[3:]   // <=> s3 := s1[3:7]
	s4 := s0[3:5]  // <=> s4 := s0[3:5:7]
	s5 := s4[:2:2] // <=> s5 := s0[3:5:5]
	s6 := append(s4, 77)
	s7 := append(s5, 88)
	s8 := append(s7, 66)
	s3[1] = 99
	fmt.Println(len(s2), cap(s2), s2) // 2 6 [1 2]
	fmt.Println(len(s3), cap(s3), s3) // 4 4 [3 99 77 6]
	fmt.Println(len(s4), cap(s4), s4) // 2 4 [3 99]
	fmt.Println(len(s5), cap(s5), s5) // 2 2 [3 99]
	fmt.Println(len(s6), cap(s6), s6) // 3 4 [3 99 77]
	fmt.Println(len(s7), cap(s7), s7) // 3 4 [3 4 88]
	fmt.Println(len(s8), cap(s8), s8) // 4 4 [3 4 88 66]
}
```

下面这张图描绘了上面的程序在退出之前各个数组和切片的状态。

![](/Users/zhangwei/Pictures/mdpic/slice-subslice-2.png)

从这张图片可以看出，切片`s7`和`s8`共享存储它们的元素的底层内存片段，其它切片和数组`a`共享同一个存储元素的内存片段。



