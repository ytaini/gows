/*
 * @Author: wzmiiiiii
 * @Date: 2022-07-16 06:20:04
 * @LastEditors: wzmiiiiii
 * @LastEditTime: 2022-11-20 11:53:41
 * @Description:
 */
package gofunc

import (
	"fmt"
	"testing"
)

/*
如果一个返回结果声明中的结果名称没有省略，则这个返回结果称为有名返回结果。否则称为匿名返回结果。

如果一个函数带有返回值，则它的一个调用被视为一个表达式。

	如果此函数返回多个结果，则它的每个调用被视为一个多值表达式。
	一个多值表达式可以被同时赋值给多个目标值（数量必须匹配，各个输出结果被赋值给相对应的目标值）

一个函数调用可以被延迟执行或者在另一个协程（goroutine，或称绿色线程）中执行

在Go中，当一个函数调用返回后（比如执行了一个return语句或者函数中的最后一条语句执行完毕）， 此调用可能并未立即退出。

	一个函数调用从返回开始到最终退出的阶段称为此函数调用的退出阶段（exiting phase）。

Go支持匿名函数。定义一个匿名函数和声明一个函数类似，但是一个匿名函数的定义中不包含函数名称部分。

	注意匿名函数定义不是一个函数声明。

	事实上，Go中的所有的自定义函数（包括声明的函数和匿名函数）都可以被视为闭包。
	这就是为什么Go中的函数使用起来和动态语言中的函数一样灵活。
*/
func TestEg1(t *testing.T) {
	var f = func() {
		fmt.Println("f 函数被调用")
	}
	f()
}

/*
内置函数

	我们可以使用内置函数real和imag来得到一个复数的实部和虚部（均为浮点数类型）。
	 注意，如果这两个函数的任何一个调用的实参是一个常量，则此调用将在编译时刻被估值，其返回结果也是一个常量。
	  此调用将被视为一个常量表达式。特别地，如果此实参是一个类型不确定值，则返回结果也是一个类型不确定值。
*/
func TestEg22(t *testing.T) {
	const r = real(1)
	const i = imag(1)
	fmt.Println(r, i)

	const c = complex(1.6, 3.3)
	// 函数调用real(c)和imag(c)的结果都是类型不确定浮点数值。
	// 在下面这句赋值中，它们都被推断为float32类型的值。
	var a, b float32 = real(c), imag(c)

	// 变量d的类型被推断为内置类型complex64。
	// 函数调用real(d)和imag(d)的结果都是类型为float32的类型确定值。
	var d = complex(a, b)
	// var r1 = real(d)
	// var i2 = imag(d)

	// 变量e的类型被推断为内置类型complex128。
	// 函数调用real(e)和imag(e)的结果都是类型为float64的类型确定值。
	var e = c

	_, _ = d, e
}
