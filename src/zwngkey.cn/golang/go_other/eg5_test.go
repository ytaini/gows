/*
 * @Author: zwngkey
 * @Date: 2022-05-12 20:40:31
 * @LastEditors: zwngkey 18390924907@163.com
 * @LastEditTime: 2022-05-12 22:07:26
 * @Description:
	go 中的内存块
*/
package goother

import "testing"

/*
	Go是一门支持自动内存管理的语言，比如自动内存开辟和自动垃圾回收。 所以Go程序员在编程时无须进行各种纷繁的内存管理操作。

	在Go编程中，尽管我们无须知道底层的自动内存管理是如何实现的，但是知道自动内存管理实现中的一些概念和事实对我们写出高质量的Go代码是非常有帮助的。

	一个内存块是一段在运行时刻承载着若干 值部 的 连续内存片段。 不同的内存块的大小可能不同，因它们所承载的值部的尺寸而定。
		一个内存块同时可能承载着 不同Go值 的若干值部，但是一个值部在内存中绝不会跨内存块存储，无论此值部的尺寸有多大。

	内存块将被开辟在何处？
		对每一个使用标准编译器编译的Go程序，在运行时刻，每一个协程将维护一个栈（stack）。
			一个栈是一个预申请的内存段，它做为一个内存池供某些内存块从中开辟。 每个协程的初始栈大小比较小（2KiB）。
			 每个栈的大小在协程运行的时候将按照需要增长和收缩。

		（注意：Go运行时维护着一个协程栈的最大尺寸限制，此限制为全局的。
			如果一个协程在增长它的栈的时候超过了此限制，整个程序将崩溃。
			对于目前的Go 1.18版本，此最大限制的默认值在64位系统上为1GB，在32位系统上为250MB。
			 我们可以在运行时刻调用runtime/debug标准库包中的SetMaxStack来修改此值。
			 另外请注意，当前的官方标准编译器实现中，实际上允许的协程栈的最大尺寸为不超过最大尺寸限制的2的幂。
			 所以对于默认设置，实际上允许的协程栈的最大尺寸在64位系统上为512MiB，在32位系统上为128MiB。）

		内存块可以被开辟在栈上。开辟在一个协程维护的栈上的内存块只能在此协程内部被使用（引用）。
			 其它协程是无法访问到这些内存块的。 一个协程可以无需使用任何数据同步技术而使用开辟在它的栈上的内存块上的值部。

		堆（heap）是一个虚拟的概念。每个程序只有一个堆。 一般地，如果一个内存块没有开辟在任何一个栈上，则我们说它开辟在了堆上。
			开辟在堆上的内存块可以被多个协程并发地访问。 在需要的时候，对承载在它们之上的值部的访问需要做同步。

		如果编译器觉察到一个内存块在运行时将会被多个协程访问，或者不能轻松地断定此内存块是否只会被一个协程访问，
			则此内存块将会被开辟在堆上。 也就是说，编译器将采取保守但安全的策略，
				使得某些可以安全地被开辟在栈上的内存块也有可能会被开辟在堆上。

		事实上，栈对于Go程序来说并非必要。Go程序中所有的内存块都可以开辟在堆上。 支持栈只是为了让Go程序的运行效率更高。
			1.从栈上开辟内存块比在堆上快得多；
			2.开辟在栈上的内存块不需要被垃圾回收；
			3.开辟在栈上的内存块对CPU缓存更加友好。

		如果一个内存块被开辟在某处（堆上或某个栈上），则我们也可以说承载在此内存块上的各个值部也开辟在此处。

		如果一个局部声明的变量的某些值部被开辟在堆上，则我们说这些值部以及此局部变量逃逸到了堆上。
			 我们可以运行Go官方工具链中提供的go build -gcflags -m命令来查看代码中哪些局部值的值部在运行时刻会逃逸到堆上。
			  如上所述，目前官方Go标准编译器中的逃逸分析器并不十分完美，因此某些可以安全地开辟在栈上的值也可能会逃逸到了堆上。


		在运行时刻，每一个仍在被使用中的逃逸到堆上的值部肯定被至少一个开辟在栈上的值部所引用着。
			如果一个逃逸到堆上的值是一个被声明为T类型的局部变量，则在运行时，一个*T类型的隐式指针将被创建在栈上。
			此指针存储着此T类型的局部变量在堆上的地址，从而形成了一个从栈到堆的引用关系。
			另外，编译器还将所有对此局部变量的使用替换为对此指针的解引用。
			此*T值可能从今后的某一时刻不再被使用从而使得此引用关系不再存在。
			此引用关系在下面介绍的垃圾回收过程中发挥着重要的作用。

		类似地，我们可以认为每个包级变量（常称全局变量）都被开辟在了堆上，并且它被一个开辟在全局内存区上的隐式指针所引用着。
			事实上，此指针引用着此包级变量的直接部分，此直接部分又引用着其它的值（部）。

		一个开辟在堆上的内存块可能同时被开辟在若干不同栈上的值部所引用着。

		一些事实：
			如果一个结构体值的一个字段逃逸到了堆上，则此整个结构体值也逃逸到了堆上。
			如果一个数组的某个元素逃逸到了堆上，则此整个数组也逃逸到了堆上。
			如果一个切片的某个元素逃逸到了堆上，则此切片中的所有元素都将逃逸到堆上，但此切片值的直接部分可能开辟在栈上。
			如果一个值部v被一个逃逸到了堆上的值部所引用，则此值部v也将逃逸到堆上。

		使用内置new函数开辟的内存可能开辟在堆上，也可能开辟在栈上。


		当一个协程的栈的大小改变时，一个新的内存段将申请给此栈使用。原先已经开辟在老的内存段上的内存块将很有可能被转移到新的内存段上，
			或者说这些内存块的地址将改变。 相应地，引用着这些开辟在此栈上的内存块的指针（它们同样开辟在此栈上）中存储的地址也将得到刷新。

*/
// 下面是一个展示开辟在栈上的值的地址改变的例子。
func f(i int) byte {
	type T int          // 防止f被内联
	var a [1 << 20]byte // 使栈增长
	return a[i]
}

func Test51(t *testing.T) {
	var x int
	println(&x)
	f(100)
	println(&x)
}

/*
	一个内存块在什么条件下可以被回收？
		为包级变量的直接部分开辟的内存块永远不会被回收。

		每个协程的栈将在此协程退出之时被整体回收，此栈上开辟的各个内存块没必要被一个一个单独回收。 栈内存池并不由垃圾回收器回收。

		对一个开在堆上的内存块，当它不再被任何开辟 在协程栈上还在使用的值部 或 全局内存区上的值部所 直接或者间接地 引用着，
			则此内存块可以被安全地垃圾回收了。 我们称这样的内存块为不再被使用的内存块。
				开辟在堆上的不再被使用的内存块将在以后某个时刻被垃圾回收器回收掉。
*/
//下面是一个展示了一些内存块在何时可以被垃圾回收的例子。
var p *int

func Test52(t *testing.T) {
	done := make(chan bool)
	// done通道将被使用在主协程和下面将要
	// 创建的新协程中，所以它将被开辟在堆上。

	go func() {
		x, y, z := 123, 456, 789
		_ = z  // z可以被安全地开辟在栈上。
		p = &x // 因为x和y都曾经被包级指针p所引用过，
		p = &y // 因此，它们都将开辟在堆上。

		// 到这里，x已经不再被任何其它值所引用。或者说承载
		// 它的内存块已经不再被使用。此内存块可以被回收了。

		p = nil
		// 到这里，y已经不再被任何其它值所引用。
		// 承载它的内存块可以被回收了。

		done <- true
	}()

	<-done
	// 到这里，done已经不再被任何其它值所引用。一个
	// 聪明的编译器将认为承载它的内存块可以被回收了。
}

/*
	如何判断一个内存块是否仍在被使用？
		目前的官方Go标准运行时（1.18版本）使用一个并发三色（tri-color）标记清扫（mark-sweep）算法来实现垃圾回收。
			 这里仅会对此算法的原理做一个大致的描述。一个具体实现可能和此大致描述会有很多细节上的差别

		一个垃圾回收过程分为两个阶段：标记阶段和清扫阶段。
			在标记阶段，垃圾回收器（实际上是一组协程）使用三色算法来分析哪些（开辟在堆上的）内存块已经不再使用了。
				1.在每一轮垃圾回收过程的开始，所有的内存块将被标记为白色。
				2.然后垃圾回收器将所有开辟在栈和全局内存区上的内存块标记为灰色，并把它们加入一个灰色内存块列表。
				3.循环下面两步直到灰色内存块列表为空：
					1.从个灰色内存块列表中取出一个内存块，并把它标记为黑色。
					2.然后扫描承载在此内存块上的指针值，并通过这些指针找到它们引用着的内存块。
					 	如果一个引用着的内存块为白色的，则将其标记为灰色并加入灰色内存块列表；否则，忽略之。

		在清扫阶段，仍被标记为白色的内存块将被认为是不再使用的而被回收掉。

		此垃圾回收算法不会移动内存块来整理内存碎片。



	不再被使用的内存块将在什么时候被回收？
		开辟在堆上的不再使用的内存块将被Go运行时认为是垃圾而将被回收，以供以后重用或者释放（给操作系统）。
			垃圾回收器并不是时刻都在运行着。它只是每隔一段时间因为某些条件达成之后才开始新的一轮垃圾回收过程。
			 所以，一个不再被使用的内存块不会在它不再使用后立即得到回收，而是将在一段时间后被逐步回收。

		目前（Go官方工具链1.18），对于使用标准编译器编译的Go程序，一轮新的垃圾回收过程开启的默认条件是通过GOGC环境变量来控制的。
		  当从上一轮垃圾回收结束后新申请的内存块的内存总和占上一轮垃圾回收结束时仍在被使用的所有内存块的内存总和的百分比超过此值时，
			新的一轮垃圾回收过程将开始。 所以此值决定了垃圾回收过程的频率。 此环境变量的默认值为100。
			  此值也可以通过调用runtime/debug.SetGCPercent函数在运行时刻被动态地修改。
				调用debug.SetGCPercent(-1)将关闭自动垃圾回收。

		一轮新的垃圾回收过程也可以通过调用runtime.GC函数来手动开启。

		另一点需要注意的是，当前的官方Go运行时（v1.18）同时采取了另一个策略：一个Go程序的最大垃圾回收时间间隔为两分钟。

		以后的Go运行时版本可能会采取不同的垃圾回收策略。

		一个不再被使用的内存块被回收后可能并不会立即释放给操作系统，这样Go运行时可以将其重新分配给其它值部使用。
			不用担心，官方Go运行时的实现比大多数主流的Java运行时要消耗少得多的内存。
*/
