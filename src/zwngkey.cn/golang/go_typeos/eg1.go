/*
 * @Author: zwngkey
 * @Date: 2022-05-01 00:14:28
 * @LastEditTime: 2022-05-02 11:38:02
 * @Description: go类型系统
 */
package gotypeos

/*
	Go类型系统
		基本类型（basic type）
		组合/复合类型（composite type）

	Go支持下列组合类型：
		指针类型 - 类C指针
		结构体类型 - 类C结构体
		函数类型 - 函数类型在Go中是一种一等公民类别
		容器类型，包括:
			数组类型 - 定长容器类型
			切片类型 - 动态长度和容量容器类型
			映射类型（map）- 也常称为字典类型。在标准编译器中映射是使用哈希表实现的。
		通道类型 - 通道用来同步并发的协程
		接口类型 - 接口在反射和多态中发挥着重要角色


	定义类型和非定义类型（defined type and undefined type）
		一个定义类型是一个在某个 类型定义声明 中定义的类型。
			即显式的写出了type i int 这种类型定义,这个类型i就是定义类型.

		所有的基本类型都是定义类型。一个非定义类型一定是一个组合类型。

		在下面的例子中，类型A和别名B均表示同一个定义类型, 别名C和类型字面表示[]string都表示同一个非定义类型。
			type A []string
			type B = A
			type C = []string


	非定义组合类型可以用它们各自的字面表示形式来表示。
	 下面是一些各种不同种类的非定义组合类型字面表示形式的例子:

		// 假设T为任意一个类型，Tkey为一个支持比较的类型。
		*T         // 一个指针类型
		[5]T       // 一个元素类型为T、元素个数为5的数组类型
		[]T        // 一个元素类型为T的切片类型
		map[Tkey]T // 一个键值类型为Tkey、元素类型为T的映射类型

		// 一个结构体类型
		struct {
			name string
			age  int
		}

		// 一个函数类型
		func(int) (bool, string)

		// 一个接口类型
		interface {
			Method0(string) int
			Method1() (int, bool)
		}

		// 几个通道类型
		chan T
		chan<- T
		<-chan T


	类型的种类
		每种上面提到的基本类型和组合类型都对应着一个类型种类（kind）。
			除了这些种类，今后将要介绍的非类型安全指针类型属于另外一个新的类型种类。

		所以，目前（Go 1.17），Go有26个类型种类。


	两种类型声明形式
		类型定义（type definition declaration）:类型定义又称类型定义声明
			// 定义单个类型。
			type NewTypeName SourceType

			// 定义多个类型。
			type (
				NewTypeName1 SourceType1
				NewTypeName2 SourceType2
			)
			- 新的类型名必须为标识符。包级 类型与类型别名 的名称不能为init。

			- 上例中的第二个类型声明中包含两个类型描述（type specification）。
				如果一个类型声明包含多于一个的类型描述，这些类型描述必须用一对小括号()括起来。

			注意：
				1.一个新定义的类型和它的源类型为两个不同的类型。
				2.在两个不同的类型定义中定义的两个类型肯定为两个不同的类型。
				3.一个新定义的类型和它的源类型的底层类型一致并且它们的值可以相互显式转换。
				4.类型定义可以出现在函数体内。


		类型别名声明（type alias declaration）
			类型别名也必须为标识符。同样地，类型别名可以被声明在函数体内。


	底层类型（underlying type）
		在Go中，每个类型都有一个底层类型。规则：
			1.一个内置类型的底层类型为它自己。
			2.unsafe标准库包中定义的Pointer类型的底层类型是它自己。
				（至少我们可以认为是这样。事实上，关于unsafe.Pointer类型的底层类型，官方文档中并没有清晰的说明。
					我们也可以认为unsafe.Pointer类型的底层类型为*T，其中T表示一个任意类型。）
			3.一个非定义类型（必为一个组合类型）的底层类型为它自己。
			4.在一个类型声明中，新声明的类型和源类型共享底层类型。

			// 这四个类型的底层类型均为内置类型int。
			type (
				MyInt int
				Age   MyInt
			)

			// 下面这三个新声明的类型的底层类型各不相同。
			type (
				IntSlice   []int   // 底层类型为[]int
				MyIntSlice []MyInt // 底层类型为[]MyInt
				AgeSlice   []Age   // 底层类型为[]Age
			)

			// 类型[]Age、Ages和AgeSlice的底层类型均为[]Age。
			type Ages AgeSlice


		如何溯源一个声明的类型的底层类型？
			规则很简单，在溯源过程中，当遇到一个内置类型或者非定义类型时，溯源结束。
			MyInt → int
			Age → MyInt → int
			IntSlice → []int
			MyIntSlice → []MyInt
			AgeSlice → []Age
			Ages → AgeSlice → []Age
			//[]MyInt,[]Age 这两个类型都没有显式用type声明,但他们的的确确是一种类型,这种类型就是非定义类型.

		在Go中，
			底层类型为内置类型bool的类型称为布尔类型；
			底层类型为任一内置整数类型的类型称为整数类型；
			底层类型为内置类型float32或者float64的类型称为浮点数类型；
			底层类型为内置类型complex64或complex128的类型称为复数类型；
			整数类型、浮点数类型和复数类型统称为数字值类型；
			底层类型为内置类型string的类型称为字符串类型。


	值（value）
		一个类型的一个实例称为此类型的一个值。一个类型可以有很多不同的值，其中一个为它的零值。
			同一类型的不同值共享很多相同的属性。

		每个类型有一个零值。一个类型的零值可以看作是此类型的默认值。
			预声明的标识符nil可以看作是切片、映射、函数、通道、指针（包括非类型安全指针）和接口类型的零值的字面量表示

		在源代码中，值可以呈现为若干种形式，包括字面量、有名常量、变量和表达式。前三种形式可以看作是最后一种形式的特例

		值分为类型确定的和类型不确定的。

		Go中还有另外两种的字面量表示形式：
			函数字面量表示形式和组合字面量表示形式（composite literal）

		函数字面量表示形式用来表示函数值。事实上，一个函数声明是由一个标识符（函数名）和一个函数字面量表示形式组成。

		组合字面量表示形式用来表示结构体类型值和容器类型（数组、切片和映射）值

		指针类型、通道类型和接口类型的值没有字面量表示形式。




	值尺寸（value size）
		一个值存储在内存中是要占据一定的空间的。此空间的大小称为此值的尺寸。值尺寸是用字节数来衡量的。
			在Go中，当我们谈及一个值的尺寸，如果没有特殊说明，我们一般是指此值的直接部分的尺寸。
			 某个特定类别的所有类型的值的尺寸都是一样的。
			 因为这个原因，我们也常将一个值的尺寸说成是它的类型的尺寸（或值尺寸）。

		我们可以用unsafe标准库包中的Sizeof函数来取得任何一个值的尺寸。


	指针类型的基类型（base type）
		如果一个指针类型的底层类型表示为*T，则此指针类型的基类型为T所表示的类型。


	结构体类型的字段（field）
		一个结构体类型由若干成员变量组成。每个这样的成员变量称为此结构体的一个字段。
			比如，下面这个结构体类型含有三个字段：author、title和pages。
			struct {
				author string
				title  string
				pages  int
			}


	函数类型的签名（signature）
		一个函数和其类型的签名由此函数的输入参数和返回结果的类型列表组成。 函数名称和函数体不属于函数签名的构成部分。


	类型的方法（method）和方法集（method set）
		在Go中，我们可以给满足某些条件的类型声明方法。方法也常被称为成员函数。 一个类型的所有方法组成了此类型的方法集。


	接口类型的动态类型和动态值
		接口类型的值称为接口值。一个接口值可以包裹装载一个非接口值。
		 包裹在一个接口值中的非接口值称为此接口值的动态值。此动态值的类型称为此接口值的动态类型。
		  一个什么也没包裹的接口值为一个零值接口值。零值接口值的动态值和动态类型均为不存在。

		一个接口类型可以指定若干个（可以是零个）方法，这些方法形成了此接口类型的方法集。

		如果一个类型（可以是接口或者非接口类型）的方法集是一个接口类型的方法集的超集，则我们说此类型实现了此接口类型。


	一个值的具体类型（concrete type）和具体值（concrete value）
		对于一个（类型确定的）非接口值，它的具体类型就是它的类型，它的具体值就是它自己。
		一个零值接口值没有具体类型和具体值。
		对于一个非零值接口值，它的具体类型和具体值就是它的动态类型和动态值。



	容器类型
		数组、切片和映射是Go中的三种正式意义上的内置容器类型。
		有时候，字符串和通道类型也可以被非正式地看作是容器类型。
		（正式和非正式的）容器类型的每个值都有一个长度属性。


	映射类型的键值（key）类型
		如果一个映射类型的底层类型表示为map[Tkey]T，则此映射类型的键值类型为Tkey。 Tkey必须为一个可比较类型



	容器类型的元素（element）类型
		存储在一个容器值中的所有元素的类型必须为同一个类型。此同一类型称为此容器值的（容器）类型的元素类型。
			如果一个数组类型的底层类型表示为[N]T，则此数组类型的元素类型为T所表示的类型。
			如果一个切片类型的底层类型表示为[]T，则此切片类型的元素类型为T所表示的类型。
			如果一个映射类型的底层类型表示为map[Tkey]T，则此映射类型的元素类型为T所表示的类型。
			如果一个通道类型的底层类型表示为chan T、chan<- T或者<-chan T，则此通道类型的元素类型为T所表示的类型。
			一个字符串类型的元素类型总是内置类型byte（亦即uint8）


	通道类型的方向
		一个通道值可以被看作是先入先出（first-in-first-out，FIFO）队列。
			一个通道值可能是可读可写的、只读的（receive-only）或者只写的（send-only）。
				1.一个可读可写的通道值也称为一个双向通道。 一个双向通道类型的底层类型可以被表示为chan T。
				2.我们只能向一个只写的通道值发送数据，而不能从其中接收数据。 只写通道类型的底层类型可以被表示为chan<- T。
				3.我们只能从一个只读的通道值接收数据，而不能向其发送数据。 只读通道类型的底层类型可以被表示为<-chan T。


	可比较类型和不可比较类型
		下面这些类型的值不支持（使用==和!=运算标识符）比较。这些类型称为不可比较类型。
			1.切片类型
			2.映射类型
			3.函数类型
			4.任何包含有不可比较类型的字段的结构体类型
			5.任何元素类型为不可比较类型的数组类型。
		其它类型称为可比较类型。

		映射类型的键值类型必须为可比较类型

		请注意：
			尽管映射，切片和函数值不支持比较，但是它们的值可以与类型不确定的nil标识符比较。
			如果两个接口值的动态类型相同且不可比较，那么在运行时比较这两个接口的值会产生一个恐慌。

*/
func F1() {

}

/*
	值部（value part）
		在运行时刻，很多值是存储在内存的。
			每个这样的值都有一个直接部分，但是有一些值还可能有一个或多个间接部分。
			  每个值部分在内存中都占据一段连续空间。
			  通过安全或者非安全指针，一个值的间接部分被此值的直接部分所引用。


		在C中，值的内存结构都是很透明的；但在Go中，对于某些类型的值，其内存结构却不是很透明。
			在C中，每个值在内存中只占据一个内存块（一段连续内存）；但是，一些Go类型的值可能占据多个内存块。
			以后，我们称一个Go值分布在不同内存块上的部分为此值的各个值部（value part）。
			一个分布在多个内存块上的值含有一个直接值部和若干被此直接值部引用着的间接值部。

		Go类型分为两大类别（category）
			两个类别（category）中的类型（type）种类（kind）
				每个值在内存中只分布在一个内存块上的类型: 单直接值部
					布尔类型
					各种数值类型
					指针类型
					非类型安全指针类型
					结构体类型
					数组类型
				每个值在内存中会分布在多个内存块上的类型: 直接值部->底层间接值部
					切片类型
					映射类型
					通道类型
					函数类型
					接口类型
					字符串类型

		注意：
			接口类型和字符串类型值是否包含间接部分取决于具体编译器实现。
				如果不使用非类型安全途径，我们无法从这两类类型的值的外在表现来判定它们的值是否含有间接部分。
				但我们认为这两类类型的值是可能包含间接值部的。

			同样地，函数类型的值是否包含间接部分几乎也是不可能验证的。 我们认为函数值是可能包含间接值部的。


		通过封装了很多具体的实现细节，第二个类别中的类型给Go编程带来了很大的便利。
			不同的编译器实现会采用不同的内部结构来实现这些类型，但是这些类型的值的外在表现必须满足Go白皮书中的要求。

		我们可以使用第一个分类中的类型来实现第二个分类中的类型。
			但是，通过将一些常用或者很独特的功能封装到此第二个分类中的类型里，使用Go编程的效率将得到大大提升，体验将得到大大增强。

		另一方面，这些封装同时也隐藏了这些类型的值的内部结构，使得Go程序员不能对这些类型有一个更全局更深刻的认识。
			有时候这会对更好地理解Go带来了一些障碍


		Go中的两种指针类型
			1.类型安全的指针。
			2.非类型安全的指针类型。
				非类型安全的指针类型提供在unsafe标准库包中。
				非类型安全指针类型通常使用unsafe.Pointer来表示。
				unsafe.Pointer类似于C语言中的void*。

			一个指针值存储着另一个值的地址，除非此指针值是一个nil空指针。
			 我们可以说此指针引用着另外一个值，或者说另外一个值正被此指针所引用。 一个值可能被间接引用，比如
			 	1.如果一个结构体值 a 含有一个 指针字段b 并且这个 指针字段b 引用着另外一个 值c，
				 	那么我们可以说结构体值a也引用着值c。
				2.如果一个值x（直接或者间接地）引用着另一个值y，并且值y（直接或者间接地）引用着第三个值z
					，则我们可以说值x间接地引用着值z。

			我们将一个含有（直接或者间接）指针字段的结构体类型称为一个指针包裹类型，
			   将一个含有（直接或者间接）指针的类型称为指针持有者类型。
			    指针类型和指针包裹类型都属于指针持有者类型。元素类型为指针持有者类型的数组类型也是指针持有者类型


		第二个分类中的类型的（可能的）内部实现结构定义
			为了更好地理解第二个分类中的类型的值的运行时刻行为，我们可以认为这些类型在内部是使用第一个分类中的类型来定义的

			映射、通道和函数类型的内部定义
				// 映射类型
				type _map *hashtableImpl // 目前，官方标准编译器是使用
										// 哈希表来实现映射的。
				// 通道类型
				type _channel *channelImpl
				// 函数类型
				type _function *functionImpl

				从这些定义，我们可以看出来，这三个种类的类型的内部结构其实是一个指针类型。
					或者说，这些类型的值的直接部分在内部是一个指针。
					这些类型的每个值的直接部分引用着它的具体实现的底层间接部分。


			切片类型的内部定义
				type _slice struct {
					elements unsafe.Pointer // 引用着底层的元素
					len      int            // 当前的元素个数
					cap      int            // 切片的容量
				}
				从这个定义可以看出来，一个切片类型在内部可以看作是一个指针包裹类型。
				 每个非零切片值包含着一个底层间接部分用来存储此切片的元素。
				  一个切片值的底层元素序列（间接部分）被此切片值的elements字段所引用。


			字符串类型的内部结构
				type _string struct {
					elements *byte // 引用着底层的byte元素
					len      int   // 字符串的长度
				}
				从此定义可以看出，每个字符串类型在内部也可以看作是一个指针包裹类型。
				 每个非零字符串值含有一个指针字段 elements。 这个指针字段引用着此字符串值的底层字节元素序列


			接口类型的内部定义
			  我们可以认为接口类型在内部是如下定义的：
				type _interface struct {
					dynamicType  *_type         // 引用着接口值的动态类型
					dynamicValue unsafe.Pointer // 引用着接口值的动态值
				}
				事实上，上面这个内部定义只用于表示空接口类型的值。空接口类型没有指定任何方法。

				从这个定义来看，接口类型也可以看作是一个指针包裹类型。
					一个接口类型含有两个指针字段。
					 每个非零接口值的（两个）间接部分分别存储着此接口值的动态类型和动态值。
					  这两个间接部分被此接口值的直接字段dynamicType和dynamicValue所引用。


			  非空接口类型的内部定义如下：
				type _interface struct {
					dynamicTypeInfo *struct {
						dynamicType *_type       // 引用着接口值的动态类型
						methods     []*_function // 引用着动态类型的对应方法列表
					}
					dynamicValue unsafe.Pointer // 引用着动态值
				}
				一个非空接口类型的值的dynamicTypeInfo字段的methods字段引用着一个方法列表。
				 此列表中的每一项为此接口值的动态类型上定义的一个方法，
				  此方法对应着此接口类型所指定的一个同原型的方法。


		在赋值中，底层间接值部将不会被复制:
			了解了第二个分类中的类型的内部结构是一个指针持有（指针或者指针包裹）类型。
				 这对于我们理解Go中的值复制行为有很大帮助。

			在Go中，每个赋值操作（包括函数调用传参等）都是一个值的浅复制过程（假设源值和目标值的类型相同）。
			 换句话说，在一个赋值操作中，只有源值的直接部分被复制给了目标值。
			  如果源值含有间接部分，则在此赋值操作完成之后，目标值和源值的直接部分将引用着相同的间接部分。
			   换句话说，两个值将共享底层的间接值部.

			事实上，对于字符串值和接口值的赋值，上述描述在理论上并非百分百正确。
			 官方FAQ明确说明了在一个接口值的赋值中，接口的底层动态值将被复制到目标值。
			  但是，因为一个接口值的动态值是只读的，所以在接口值的赋值中，官方标准编译器并没有复制底层的动态值。
			   这可以被视为是一个编译器优化。 对于字符串值的赋值，道理是一样的。所以对于官方标准编译器来说，上一段的描述是100%正确的。

			因为一个间接值部可能并不专属于任何一个值，所以在使用unsafe.Sizeof函数计算一个值的尺寸的时候，
			 此值的间接部分所占内存空间未被计算在内。


		关于术语“引用类型”和“引用值”
			并不是想说引用类型这个术语在Go中是完全没有价值的，
			 只是想表达这个术语是完全没有必要的，并且它常常在Go的使用中导致一些困惑。
			  推荐使用指针持有者类型来代替这个术语。
			另外，个人的观点是最好 将引用这个词限定到 只表示值之间的关系，把它当作一个动词或者名词来使用，
			 永远不要把它当作一个形容词来使用。 这样将在使用Go的过程中避免很多困惑。
*/
