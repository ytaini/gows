package goconstvar

/*
	变量声明和赋值操作语句
		变量可以被看作是在运行时刻存储在内存中并且可以被更改的有名字的值。

		所有的变量值都是类型确定值。当声明一个变量的时候，我们必须在代码中给编译器提供足够的信息来让编译器推断出此变量的确切类型。

		如果一个初始值是一个类型确定值，则对应声明的变量的类型将被推断为此初始值的类型；
		如果一个初始值是一个类型不确定值，则对应声明的变量的类型将被推断为此初始值的默认类型

	纯赋值语句
		空标识符也可以出现在纯赋值语句的左边，表示不关心对应的目标值。 空标识符不可被用做源值

		注意，相对于纯赋值语句，目前短声明语句有一个限制：出现在一个短声明左侧的项必须都为纯标识符。
		以后我们将学习到在纯赋值语句的左边可以出现结构体值的字段，指针的解引用和容器类型值的元素索引项等。
		但是这些项不能出现在一个变量短声明语句的左边。

		一般来说，如果x可以被赋给y，则y应该是可修改的，并且x和y的类型相同或者x可以被隐式转换到y的类型。 当然，y也可以是空标识符_。

*/
const N = 123

var x int
var y, z float32

func Testeg21() {
	// N = 789 // error: N是一个不可变量
	y = N // ok: N被隐式转换为类型float32
	// x = y // error: 类型不匹配
	x = N // ok: N被隐式转换为类型int
	// y = x // error: 类型不匹配
	z = y // ok
	_ = y // ok

	z, y = y, z     // ok
	_, y = y, z     // ok
	z, _ = y, z     // ok
	_, _ = y, z     // ok
	x, y = 69, 1.23 // ok
	// x, y = y, x               // error: 类型不匹配
	x, y = int(y), float32(x) // ok
}

/*
	若干包级变量在声明时刻的依赖关系将影响它们的初始化顺序

	下面这个例子中的声明的变量的初始化顺序为y = 5、c = y、b = c+1、a = b+1、x = a+1。
*/
var x1, y1 = a + 1, 5          // 8 5
var a, b, c = b + 1, c + 1, y1 // 7 6 5
// 包级变量在初始化的时候不能相互依赖。比如，下面这个变量声明语句编译不通过。
// var x, y = y, x

/*
	值的可寻址性
		在Go中，有些值是可以被寻址的。所有变量都是可以寻址的，所有常量都是不可被寻址。
*/

/*
	非常量数字值相关的显式类型转换规则
		在Go中，两个类型不一样的基本类型值是不能相互赋值的.
		 我们必须使用显式类型转换将一个值转换为另一个值的类型之后才能进行赋值。


		整数（不论常量还是非常量）都可以被显式转换为字符串类型。

		两个不同类型数字值之间的转换规则。
			一个非常量浮点数和整数可以显式转换到其它任何一个浮点数和整数类型。
			一个非常量复数可以显式转换到其它任何一个复数类型。


*/
func Testeg22() {
	var a int = 1
	var b int8 = 1
	var c int32 = 1
	var d bool = false
	var e float32 = 1
	var f float64 = 1
	var g string = "string"
	_, _, _, _, _, _, _ = a, b, c, d, e, f, g
	// a = b //error
	// a = c //error
	// a = d //error
	// e = f //error
	// f = e //error
	// g = a //error

}

/*
	常量数字值的类型转换不能溢出。
	但此规则不适用于非常量数字值的类型转换。 非常量数字值的类型转换中，溢出是允许的
	另外当将一个浮点数非常量值（比如一个变量）转换为一个整数类型的时候，舍入（或者精度丢失）也是允许的
		具体规则:
			当从一个比特位数多的整数类型的非常量整数值向一个比特位数少的整数类型转换的时候，高位的比特将被舍弃，低位的比特将被保留。我们称这种处理方式为截断（truncated）。
			当从一个非常量的浮点数向一个整数类型转换的时候，浮点数的小数部分将被舍弃（向零靠拢）。
			当从一个非常量整数或者浮点数向一个浮点数类型转换的时候，精度丢失是可以发生的。
			当从一个非常量复数向另一个复数类型转换的时候，精度丢失也是可以发生的。

*/
func Testeg23() {
	//a是一个类型不确定值,它的默认类型与-1.23默认类型一致.
	const a = -1.23
	// a被转换为它的默认类型（float64）
	// 变量b的类型被推断为内置类型float64。
	var b = a
	// error: 常量1.23不能被截断舍入到一个整数。
	// var x = int32(a)
	// error: float64类型值不能被隐式转换到int32。
	// var y int32 = b
	//     z的小数部分将被舍弃。
	var z = int32(b)
	_ = z

	const k int16 = 255
	// 变量n的类型将被推断为int16。
	var n = k
	// var f = uint8(k + 1) // error: 常量256溢出了uint8。
	// var g uint8 = n + 1  // error: int16值不能隐式转换为uint8。
	var h = uint8(n + 1) // ok: h == 0，变量h的类型为uint8。
	// (n+1)溢出uint8，所以只有低8位bits（都为0）被保留。
	_ = h

}
