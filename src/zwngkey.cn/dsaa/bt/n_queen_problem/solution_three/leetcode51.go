/*
 * @Author: wzmiiiiii
 * @Date: 2022-11-02 02:10:48
 * @LastEditors: wzmiiiiii
 * @LastEditTime: 2022-11-02 03:57:42
 * @Description:
	解法一使用三个数组存储已经放置的皇后所在的列集合、方向一斜线集合与方向二斜线集合，也可以使用三个二进制数代替三个数组。

	用col,dia1,dia2三个整数分别记录已经放置的皇后所在的列集合、方向一斜线集合与方向二斜线集合，
	  每个整数有 N 个二进制位,每个二进制整数的每一位是 1 或 0.
		1 表示该位置和已经放置的皇后在同一条直线或斜线上，该位置不能放置皇后。
		0 表示该位置和已经放置的皇后都不在同一列或同一条斜线上，该位置可以放置皇后。

	棋盘的每一列对应每个整数的二进制表示中的一个数位，其中棋盘的最左列对应每个整数的最低二进制位，最右列对应每个整数的最高二进制位。

	三个整数的计算方法：
		- 初始时，三个整数的值都等于 0，表示没有放置任何皇后；
		- 在当前行放置皇后，如果皇后放置在第 i 列，则将三个整数的第 i 个二进制位（指从低到高的第 i 个二进制位）的值设为 1
		- 进入下一行时，col 的值保持不变,dia1 左移一位，dia2右移一位，
			由于棋盘的最左列对应每个整数的最低二进制位，即每个整数的最右二进制位，因此对整数的移位操作方向和对棋盘的移位操作方向相反
			（对棋盘的移位操作方向是dia1右移一位,dia2左移一位)
	每次放置皇后时，三个整数的按位或运算的结果即为不能放置皇后的位置，其余位置即为可以放置皇后的位置。
	可以通过 (1<<n - 1) & (~col|dia1|dia2)得到可以放置皇后的位置（该结果的值为 1 的位置表示可以放置皇后的位置），
	然后遍历这些位置，尝试放置皇后并得到可能的解。

	遍历可以放置皇后的位置时，可以利用以下两个按位与运算的性质：
		x & (-x) 可以获得 x 的二进制表示中的最低位的 1 的位置；
		x & (x-1) 可以将 x 的二进制表示中的最低位的 1 置成 0。

	具体做法是，每次获得可以放置皇后的位置中的最低位，并将该位的值置成 00，尝试在该位置放置皇后。这样即可遍历每个可以放置皇后的位置。

*/
/*
	x & -x。这个操作可以保留最后一位1，而其他位都会清零。比如，一个8位数，00110110.进行了这个操作后就会变为00000010.

*/
package main

import "fmt"

func totalNQueens(n int) (ans int) {
	var bt func(row, cols, dia1, dia2 int)

	bt = func(row, cols, dia1, dia2 int) {
		if row == n {
			ans++
			return
		}
		bits := (1<<n - 1) & ^(cols | dia1 | dia2)
		for bits > 0 {
			pick := bits & -bits
			bt(row+1, cols|pick, (dia1|pick)<<1, (dia2|pick)>>1)
			bits &= bits - 1 //bits &^= pick 这两个操作等价
		}
	}
	bt(0, 0, 0, 0)
	return
}

func main() {
	fmt.Printf("totalNQueens(8): %v\n", totalNQueens(8))
}

/*
	1.(1 << n) - 1 这个语句实际上生成了n个1.这里的1表示可以放置皇后（其实就是初始化了n个1，在不考虑皇后之间可以相互攻击的情况下，n个位置都可以放皇后）；
		^(col | ld | rd)这里的三个变量分别代表了列以及两个斜线的放置情况。将他们取反后,这里的1也就表示能放置皇后了.
		这样就与之前 (1 << n) - 1生成的n个1是相同含义了。因此bits = ^(col | ld | rd) & ((1 << n) - 1)表示的是考虑了相应列、斜线后能放置皇后的位置。
					cols 					00010
					dia1 					00100
					dia2 					00001
		(col | ld | rd)	 					00111  这上面的1表示不能放置皇后
		^(col | ld | rd) 			  ...11111000
		(1 << 5) - 1  				  ...00011111
^(col | ld | rd) & ((1 << n) - 1)     ...00011000  这里的1表示可以放置皇后

	2.当bits>0时，说明bits中还有1存在，就说明遍历还没有完成。而在之后的循环体中，每遍历bits中的一个1，就会将其清0，这就是代码中注释部分5的语句。
	3.这里的pick就是取出了最后一位1，表示此时遍历的是这种情况。假设bits为0110，取出最后一位1后，就变为0010，就是将皇后放在第3个位置。
	4.这里是核心：row+1不难理解，就是因为之前已经在row行放置了皇后了，现在应该搜索下一行可能的位置了。
		col | pick就是把目前所有放置皇后的列都计算出来了，比如最开始计算时col是0000，pick是0010,那么col | pick就是0010，意思就是第三列被放置过了。
		接着说，假设dia1是0000，dia1 | pick就是0010，左移1位后变成了0100，意思就是下一行的第二列也不要放皇后了，因为在这一行的第三列我已经放过了，他们是位于一个斜线上的。
		(dia2 | pick) >> 1跟(dia1 | pick) << 1是一个含义，
*/
