[TOC]

# 树
- 树是一种非线性数据结构，它是由n(n≥0)个有限节点组成一个具有层次关系的集合
- 特点:
  - 每个节点有零个或多个子节点；
  - 没有父节点的节点称为根节点；
  - 每一个非根节点有且只有一个父节点；
  - 除了根节点外，每个子节点可以分为多个不相交的子树。
  
<br>

1. 每个元素称为节点（node）
2. 有一个特定的节点被称为根节点或树根（root）
2. 除根节点之外的其余数据元素被分为m(m>=0)个互不相交的集合T1,T2,T3...Tm，其中每一个集合Ti(1<=i<=m)本身也是一棵树，被称作原树的子树（subtree）。

<br>

术语:
- 空集合也是树，称为空树。空树中没有节点；
- 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；
- 节点的度：一个节点含有的子节点的个数称为该节点的度；
- 叶节点或终端节点：度为0的节点称为叶节点；
- 非终端节点或分支节点：度不为0的节点；
- 双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
- 兄弟节点：具有相同父节点的节点互称为兄弟节点；
- 树的度：一棵树中，最大的节点的度称为树的度；
- 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
- 树的高度或深度：树中节点的最大层次；
- 堂兄弟节点：双亲在同一层的节点互为堂兄弟；
- 节点的祖先：从根到该节点所经分支上的所有节点；
- 子孙：以某节点为根的子树中任一节点都称为该节点的子孙；
- 森林：由m(m>=0)棵互不相交的树的集合称为森林。

<br>

种类:
- 无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树；
- 有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树；
  - 二叉树：每个节点最多含有两个子树的树称为二叉树；
    - 完全二叉树：除最后一层外，所有层都是满节点，且最后一层缺右边连续节点的二叉树称为完全二叉树；
      - 满二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树；
    - 哈夫曼树（最优二叉树）：带权路径最短的二叉树称为哈夫曼树或最优二叉树。
    - 二叉查找树（二叉搜索树、二叉排序树、BST）
      - 平衡二叉树     
        - AVL树
        - 红黑树
        - 替罪羊树
        - 伸展树
    - 线索二叉树
  - B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。
    - B+树
    - B*树

<br>

遍历表达法:
- 遍历表达法有4种方法：先序遍历、（仅二叉树有中序遍历）、后序遍历、层次遍历

<br>
<br>

## 二叉树
概念:
- 二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。
- 通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。

<br>

> 需要注意的是，二叉树并不是树的特殊情况，他们是两个概念。

```
二叉树结点的子树要区分左子树和右子树，即便只有一棵子树也要进行区分，说明他是左子树还是右子树。二树，当结点只有一个孩子时，就无需区分它是左还是右的次序。这是二者的主要区别。（也就是说二叉树每个结点位置或者说次序都是固定的，可以是空，但是不可以说它没有的位置，二树的结点位置是相对别的结点来说的，没有别的结点时，他就无所谓左右了）
```

<br>

**为什么要重点研究每节点最多只有两个"叉"的树?**
- **二叉树的结构简单,规律性最强.**
- **可以证明,所有树都能转为唯一对应的二叉树,不失一般性.**

<br>

**普通树(多叉树)若不转为二叉树,则运算很难实现.** 

<br>

**二叉树在树结构的应用中起着非常重要的作用,因为对二叉树的操作算法简单,**
**而任何树都可以与二叉树相互转换,这样就解决了树的存储结构及其运算中存在的复杂性.**

<br>


**二叉树的性质:**

- **在二叉树的第i层至多有2^(i-1)^个结点(i ≥ 1),第i层至少1个结点**
- **深度为k的结点至多有2^k^-1个结点 [深度为k的二叉树最少有k个结点]**
- **对任何一棵非空的二叉树T，如果其叶子数为n~0~,度为2的结点数为n~2~，则n~0~ = n~2~ + 1**
  - 设总边数为B,总结点为n.度为1的结点数为n~1~
    - B = n - 1, B = n~2~\*2 + n~1~\*1
    - n =  n~2~\*2 + n~1~\*1 + 1 又∵ n = n~2~ + n~1~ + n~0~
    - ∴ n~0~ = n~2~ + 1

<br>

## 树与二叉树的转换

变换自多叉树
- 一般有序树可映射为二叉树，但反之未必成立
- n叉树变换为二叉树的方法：
  - 二叉树中结点x的左子结点为n叉树中结点x的左子结点；
  - 二叉树中结点x的右子结点为n叉树中结点x的第一个右边的同级结点y。
- 二叉树当且仅当根节点没有右子结点时可转换为n叉树。

<br>

[树、森林和二叉树的转换详解](https://www.shouxicto.com/article/2665.html)

<br>

将一棵树变换为二叉树的方法：
- 在所有兄弟之间加一连线；
- 对每个结点，除了其左孩子外，去除其与其余孩子之间的联系；
- 以树的根结点为轴心，将整树顺时针转45度。

<br>

森林转换为二叉树:
  森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。步骤如下：
- 把每个树转换为二叉树。
- 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。


<br>

二叉树案例:
- 数据压缩问题.
- 求解表达式的值.

<br>
<br>

### 满二叉树
一棵深度为k(k≥1)且有2^k^-1个结点的二叉树称为满二叉树.**国外定义这种二叉树为完美二叉树.**

<br>

性质:对于一颗深度为k的完美二叉树:
- 共有2^k^-1个结点
- 结点个数一定为奇数
- 第i层有2^i-1^个结点
- 有2^k-1^个叶子.

**国外定义的满二叉树: 如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。**


<br>
<br>

### 完全二叉树  

在一颗二叉树中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树为完全二叉树（Complete Binary Tree）

性质:
1. 具有n个节点的完全二叉树的深度为log~2~n+1.
2. 深度为k的完全二叉树，至少有2^k-1^个节点,至多有2^k^-1个结点.
3. 如果对一棵有n个结点的完全二叉树（深度为log~2~n+1）的结点按层序编号(从第一层到第log~2~n+1层，每层从左到右)，则对任一结点i(1≤i≤n)有：
   - 如果i=1，则结点i是二叉树的根，无双亲：若i>1，则其双亲是结点i/2.
   - 若2i>n，则结点i为叶子结点，无左孩子；否则，其做孩子是2i
   - 若2i+1>n,则结点i无右孩子；否则，其右孩子是结点2i+1


<br>
<br>

## 二叉树的存储结构

- 顺序存储
- 链式存储
  - 二叉链表
  - 三叉链表
<br>

二叉树的顺序存储
  实现:按满二叉树的结点层次编号.依次存放二叉树中的数据元素.结点为空时就置空.
  顺序存储有明显的缺点，当最坏情况下，深度为k的且只有k个结点的单支树需要长度为2^k-1^的一维数组,最坏情况下很容易浪费空间的。
  所以顺序储存比较适合满二叉树和完全二叉树。

<br>

二叉树的链式储存
  二叉树每个结点都可以有两个孩子，所以可以又叫做二叉链表，即两个指针分别指向左右孩子
  但是在我们需要找某个结点双亲的时候，二叉链表就不太方便了，所以我们需要三叉链表.
<br>

> 在n个结点的二叉链表中,有n+1个空指针域.

```
分析:必有2n个链域.除根节点外,每个节点有且仅有一个双亲,所有只有会n-1个结点的链域存放指针.指向非空孩子结点.
所以,空指针域 = 2n - (n-1) = n+1
```

<br>
<br>


## 遍历二叉树

- 遍历定义：顺着某一条搜索路径巡访二叉树中的结点，使得每一个结点被访问一次且仅被访问一次.
  - "访问"的含义很广，可以是对结点进行各种处理：输出结点的信息，修改结点的数据等，但要求这种访问不破坏原来的数据结构

- 遍历的目的：得到树中所有结点的一个线性排列.

- 遍历的用途：它是树结构插入，删除，修改，查找和排序运算的前提，是所有二叉树运算的基础，核心.
<br>


三种遍历方式（始终先左后右）：
- DLR——先(根)序遍历
- LDR——中(根)序遍历
- LRD——后(根)序遍历

**前序，中序和后序遍历都是深度优先遍历的特例。**
<br>
<br>


![](image/tree1.png)

![](image/tree.png)

<br>

根据遍历序列确定唯一的二叉树
- 若二叉树中各节点的值均不相同,则二叉树结点的先序序列，中序序列和后序序列都是唯一的.
- 由二叉树的先序序列和中序序列可以确定唯一一棵二叉树
- 由二叉树的后序序列和中序序列可以确定唯一一棵二叉树（必须需要中序序列做参考）

<br>
<br>

### 遍历二叉树递归算法

- 二叉树先序遍历算法
```go
func PreOrderTraverse(t BiTree){
  if t == nil {
    return 
  }
  visit(); //访问结点
  PreoOrderTraverse(t.lchild) //递归遍历左子树
  PreoOrderTraverse(t.rchild) //递归遍历右子树.
}
```



- 二叉树中序遍历算法
```go
func InOrderTraverse(t BiTree){
  if t == nil {
    return 
  }
  InOrderTraverse(t.lchild) //递归遍历左子树
  visit(); //访问结点
  InOrderTraverse(t.rchild) //递归遍历右子树.
}
```



- 二叉树后序遍历算法
```go
func PostOrderTraverse(t BiTree){
  if t == nil {
    return 
  }
  PostOrderTraverse(t.lchild) //递归遍历左子树
  PostOrderTraverse(t.rchild) //递归遍历右子树.
  visit(); //访问结点
}
```
<br>

遍历算法分析:
- 从递归的角度看,三种算法是完全相同的,或说这三种算法的访问路径是相同的,只是访问结点的时机不同.
  - 第一次经过时访问 => 先序遍历
  - 第二次经过时访问 => 中序遍历
  - 第三次经过时访问 => 后序遍历

<br>
<br>

### 变量二叉树非递归算法

- 中序遍历非递归算法.
  - 二叉树中序遍历的非递归算法的关键:在中序遍历过某结点的整个左子树后,如何找到该节点的根以及右子树.
  - 基本思想:
    1. 建立一个栈
    2. 根节点进栈,遍历左子树
    3. 根节点出栈,输出根节点,遍历右子树.
```go
func InOrderTraverse(t BiTree){
  s := InitStack()
  p := t;
  for p != nil || !s.StackEmpty() {
    if p != nil {
      s.Push(p)
      p = p.lchild
    }else {
      q := s.Pop()
      fmt.Println(q.data)
      p = q.rchild
    }
  }
}
```

<br>
<br>

### 二叉树的层次遍历
通过BFS实现.
```go
func LevelOrder(root BTNode){
  q := InitQueue()
  q.InQueue(root) //根节点入队
  for !q.QueueEmpty() {
    p := q.outQueue()
    fmt.Println(p.data)
    if p.lchild != nil { //有左孩子时将其入队
      q.InQueue(p.lchild)
    }
    if p.rchild != nil { //有右孩子时将其入队
      q.InQueue(p.rchild) 
    }
  }
}
```

<br>
<br>

### 二叉树遍历算法的应用--二叉树的建立

- 按先序遍历序列建立二叉树的二叉链表.
  - 由于一个先序序列不能确定唯一的一棵树.所以使用"#"来表达一个空节点.
```go
func CreateBiTree(t *BiTree) *BiTree{
  ch := ''
  fmt.Scan(&ch)
  if ch == '#' {
    t = nil
  }else {
    t = NewBiTreeNode(ch)
    CreateBiTree(t.lchild)
    CreateBiTree(t.rchild)
  }
  return t
}
```
<br>

### 二叉树遍历算法的应用--复制二叉树
- 思想:
  - 如果是空树,递归结束
  - 否则,新建结点,复制根节点
    - 递归复制左子树
    - 递归复制右子树

```go
func Copy(t *BiTree,newT *BiTree) {
  if t == nil {
    newT = nil
    return
  }
  newT = NewBiTNode(t.data)
  Copy(t.lchild,newT.lchild)
  Copy(t.rchild,newT.rchild)
}
```
<br>
<br>

### 二叉树遍历算法的应用--计算树的深度

- 如果是空树,则深度为0
- 否则,递归计算左子树的深度记为m,递归计算右子树的深度记为n.二叉树的深度则为m与n的较大者加1.
```go
func Depth(t BiTree) int {
  if t == nil {
    return 0;
  }
  m := Depth(t.lchild)
  n := Depth(t.rchild)
  if m>n {
    return m + 1
  }else {
    return n + 1
  }
}
```

<br>
<br>

### 二叉树遍历算法的应用--计算结点总数
- 如果是空树，则结点个数为0；
- 否则，结点个数为左子树的叶子个数+右子树的叶子结点个数 + 1;
```go
func NodeCount(t BiTree) int {
  if t == nil {
    return 0
  }
  return NodeCount(t.lchild) + NodeCount(t.rchild) + 1
}
``` 
<br>
<br>

### 二叉树遍历算法的应用--计算叶子结点树
- 如果是空树，则结点个数为0；
- 否则，为左子树的叶子个数+右子树的叶子结点个数;
```go
func LeafCount(t BiTree) int {
  if t == nil {
    return 0
  }
  if t.lchild == nil && t.rchild == nil {
    return 1;
  }
  return LeafCount(t.lchild) + LeafCount(t.rchild)
}
```

<br>
<br>

## 线索二叉树(threaded binary tree)
> 问题:为什么要研究线索二叉树?

当用二叉链表作为二叉树的存储结构时,可以很方便地找到某个节点的左右孩子;
但一般情况下,**无法直接找到该结点在某种遍历序列中的前驱和后继结点**.
<br>

![](image/image_20221110222315093093.png)

- 利用二叉链表中的空指针域
  - 如果某个结点的左孩子为空,则将空的左孩子指针域改为指向其前驱;
  - 如果某个结点的右孩子为空,则将空的右孩子指针域改为指向其后继;

为区分lchild与rchild指针到底是指向孩子的指针,还是指向前驱或后继的指针,还需在结点结构中增加两个标志域LTag和RTag。
- LTag=0时，lchild域指示结点的左孩子
- LTag=1时，lchild域指示结点的前驱
- RTag=0时，rchild域指示结点的右孩子
- RTag=1时，rchild域指示结点的后继。

以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表

其中指向结点前驱和后继的指针叫做线索.

加上线索的二叉树称为线索二叉树.

对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。

若对二叉树进行中序遍历，则所得的线索二叉树称为中序线索二叉树，线索链表称为中序线索链表。

线索二叉树是一种物理结构。
![](image/Tbt1.jpg)


在中序线索树找结点后继的规律是：
- 若其右标志为1，则右链为线索，指示其后继，否则遍历其右子树时访问的第一个结点（右子树最左下的结点）为其后继；

找结点前驱的规律是：
- 若其左标志为1，则左链为线索，指示其前驱，否则遍历左子树时最后访问的一个结点（左子树中最右下的结点）为其前驱。

<br>

在后序线索树中找到结点的后继分三种情况：
- 若结点是二叉树的根，则其后继为空；
- 若结点是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲结点；
- 若结点是其双亲的左孩子，且其双亲有右子树，则其后继为双亲右子树上按后序遍历列出的第一个结点。

<br>

二叉树的二叉线索存储表示：
- 在线索链表上添加一个头结点，并令其lchild域的指针指向二叉树的根结点,即ltag=0，其rchild域的指针指向中序遍历时访问的最后一个结点,rtag = 1。
- 令二叉树中序序列中的第一个结点的lchild域指针和最后一个结点的rchild域的指针均指向头结点，这样就创建了一个双向线索链表。

![](image/image_202211102306119292.png)


