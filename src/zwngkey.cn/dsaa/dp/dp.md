[TOC]



# dp 动态规划

## dp题特点
1. 计数
  - 有多少中方法走到右下角
  - 有多少中方法选出k个数使得和是sum

2. 求最大最小值
  - 从左上角走到右下角路径的最大数字和
  - 最长上升子序列长度

3. 求存在性
  - 取石子游戏,先手是否必胜
  - 能不能选出k个数使得和为sum.



## dp组成部分

1. 确认状态
   - 最后一步
   - 化成子问题
2. 转移方程
3. 初始条件和边界情况.
4. 计算顺序.

**最后消除冗余,加速计算.**

## dp组成部分一:确定状态
- 状态在dp中的作用属于定海神针

- 简单的说,解dp的时候需要开一个数组,数组的每个元素f[i]或者f\[i][j]代表什么.
  - 类似于解数学题中,x,y,z代表什么.

- 确定状态需要两个意识:
  - 最后一步: 指的是最优策略中的最后一个决策.
    以:下面这道题为例:

    ```
    给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 -1.
    如:[2,5,7]
    27
    ```

    - 虽然我们不知道最优策略是什么,但是最优策略肯定是k枚硬币**a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>...a<sub>k</sub>**面值加起来是**27**

    - 所以一定有一枚最后的硬币: **a<sub>k</sub>**

    - 除掉这枚硬币后,前面硬币的面值加起来是**27-a<sub>k</sub>**

      

    - 关键点1:

      - 我们不关心前面的**k-1**枚硬币是怎么拼出**27-a<sub>k</sub>**的(可能有1中拼法,可能有100种),而且我们现在甚至不知道**a<sub>k</sub>和k**,但是我们确定前面的硬币拼出了**27-a<sub>k</sub>**,

    - 关键点2:

      - 因为是最优策略,所以拼出**27-a<sub>k</sub>**的硬币数一定要最少,否则这就不是最优策略了.

        

  - 子问题

    - 所有我们就要求:最少用多少枚硬币可以拼出**27-a<sub>k</sub>**
    - 原问题是:最少用多少枚硬币拼出**27.**
    - 我们将原问题转化成了一个子问题,而且规模更小:**27-a<sub>k</sub>**
    - 为了简化定义,我们设状态**f(x)=最少用多少枚硬币拼出x**
    - 我们还不知道最后那枚硬币**a<sub>k</sub>**是多少?
      - 最后那枚硬币只能是**2,5,7**.也就是给定切片中的各个元素.
      - **如果a<sub>k</sub>是2,f(27)应该是f(27-2)+1(加上最后这一枚硬币2)**
      - **如果a<sub>k</sub>是5,f(27)应该是f(27-5)+1(加上最后这一枚硬币5)**
      - **如果a<sub>k</sub>是7,f(27)应该是f(27-7)+1(加上最后这一枚硬币7)**
      - 除此没有其他的可能.
    - 所以:
      - 需要求最少的硬币数:**f(27)=min{ f(27-2)+1, f(27-5)+1,f(27-7)+1}**
      - f(27) 表示拼出27所需最少的硬币数
      -  f(27-2)+1 表示拼出25所需最少的硬币数,加上最后一个硬币2
      - 其他类似...
        - 所以,求f(27)就等于求f(25),f(22),f(27)中的最小值.
        - 那么又怎么求f(25),f(22),f(27)呢?    **重复上面的过程.**



### dp与递归的区别?

递归解法的问题:

- 做了很多重复计算,效率低下.
- 如何避免?
  - 将计算结果保存下来,并改变计算顺序.



## dp组成部分二:转移方程

- 设状态f[x]=最少用多少枚硬币拼出x
- **对于任意x, f[x]=min{f[x-2]+1,f[x-5]+1,f[x-7]+1}**



## dp组成部分三:初始条件和边界情况

-  **f[x]=min{f[x-2]+1,f[x-5]+1,f[x-7]+1}**
- 存在两个问题:
  - x-2,x-5,x-7不能小于0
  - 什么时候停止计算?
- 如果不能拼出Y,我们就定义f[Y]=正无穷
  - 例如:f[-1]=f[-2]=...=正无穷
- 所以f[1]=min{f[-1]+1,f[-4]+1,f[-6]+1}=正无穷,表示拼不出来.
- 初始条件:f[0] = 0.
  - 初始条件如何编写?
    - 初始条件是用转移方程无法算出的值.或转移方程计算错误的值.
    - 这时需要我们手动定义它们的值.



## dp组成部分四:计算顺序

- 拼出x所需要的最少硬币数: f[x]=min{f[x-2]+1,f[x-5]+1,f[x-7]+1}
- 初始条件:f[0]=0
- 然后计算f[1],f[2],f[3],....,f[x]
- 计算顺序如何确定?
  - 当我们计算的f[x]时,f[x-2],f[x-5],f[x-7]都已经得到结果了.



- 复杂度:
  - 每一步尝试len(coins)中硬币,一共n步.
  - 与递归算法相比,没有任何重复计算.
  - 时间复杂度:len(coins)*n
  - 递归时间复杂度: 远大于len(coins)*n.

## 编码

```go
package test1

import "math"

func CoinChange(coins []int, amount int) int {
	f := make([]int, amount+1)
	f[0] = 0

	for i := 1; i <= amount; i++ {
		f[i] = math.MaxInt
		//last coin coins[j]
		for j := range coins {
			if i >= coins[j] && f[i-coins[j]] != math.MaxInt {
				f[i] = Min(f[i-coins[j]]+1, f[i])
			}
		}
	}
	if f[amount] == math.MaxInt {
		f[amount] = -1
	}
	return f[amount]
}

```

