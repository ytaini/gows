[TOC]

# dp 动态规划

动态规划并不是某种具体的算法，而是一种解决特定问题的方法，因此它会出现在各式各样的数据结构中，与之相关的题目种类也更为繁杂。
## 基本思想

动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。**与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。** 若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。

> 为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的「状态」，图中的边则对应状态之间的「转移」，转移的选取就是动态规划中的「决策」。


## dp题特点
1. 计数
  - 有多少种方法走到右下角
  - 有多少种方法选出k个数使得和是sum

2. 求最大最小值
  - 从左上角走到右下角路径的最大数字和
  - 最长上升子序列长度

3. 求存在性
  - 取石子游戏,先手是否必胜
  - 能不能选出k个数使得和为sum.



## dp组成部分

1. 确认状态
   - 最后一步
   - 化成子问题
2. 转移方程
3. 初始条件和边界情况.
4. 计算顺序.

**最后消除冗余,加速计算.**

## dp组成部分一:确定状态
- 状态在dp中的作用属于定海神针

- 简单的说,解dp的时候需要开一个数组,数组的每个元素f[i]或者f\[i][j]代表什么.
  - 类似于解数学题中,x,y,z代表什么.

- 确定状态需要两个意识:
  - 最后一步: 指的是最优策略中的最后一个决策.
    以:下面这道题为例:

    ```
    给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 -1.
    如:[2,5,7]
    27
    ```

    - 虽然我们不知道最优策略是什么,但是最优策略肯定是k枚硬币**a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>...a<sub>k</sub>**面值加起来是**27**

    - 所以一定有一枚最后的硬币: **a<sub>k</sub>**

    - 除掉这枚硬币后,前面硬币的面值加起来是**27-a<sub>k</sub>**

      

    - 关键点1:

      - 我们不关心前面的**k-1**枚硬币是怎么拼出**27-a<sub>k</sub>**的(可能有1中拼法,可能有100种),而且我们现在甚至不知道**a<sub>k</sub>和k**,但是我们确定前面的硬币拼出了**27-a<sub>k</sub>**,

    - 关键点2:

      - 因为是最优策略,所以拼出**27-a<sub>k</sub>**的硬币数一定要最少,否则这就不是最优策略了.

        

  - 子问题

    - 所有我们就要求:最少用多少枚硬币可以拼出**27-a<sub>k</sub>**
    - 原问题是:最少用多少枚硬币拼出**27.**
    - 我们将原问题转化成了一个子问题,而且规模更小:**27-a<sub>k</sub>**
    - 为了简化定义,我们设状态**f(x)=最少用多少枚硬币拼出x**
    - 我们还不知道最后那枚硬币**a<sub>k</sub>**是多少?
      - 最后那枚硬币只能是**2,5,7**.也就是给定切片中的各个元素.
      - **如果a<sub>k</sub>是2,f(27)应该是f(27-2)+1(加上最后这一枚硬币2)**
      - **如果a<sub>k</sub>是5,f(27)应该是f(27-5)+1(加上最后这一枚硬币5)**
      - **如果a<sub>k</sub>是7,f(27)应该是f(27-7)+1(加上最后这一枚硬币7)**
      - 除此没有其他的可能.
    - 所以:
      - 需要求最少的硬币数:**f(27)=min{ f(27-2)+1, f(27-5)+1,f(27-7)+1}**
      - f(27) 表示拼出27所需最少的硬币数
      -  f(27-2)+1 表示拼出25所需最少的硬币数,加上最后一个硬币2
      - 其他类似...
        - 所以,求f(27)就等于求f(25),f(22),f(27)中的最小值.
        - 那么又怎么求f(25),f(22),f(27)呢?    **重复上面的过程.**



### dp与递归的区别?

递归解法的问题:

- 做了很多重复计算,效率低下.
- 如何避免?
  - 将计算结果保存下来,并改变计算顺序.



## dp组成部分二:转移方程

- 设状态f[x]=最少用多少枚硬币拼出x
- **对于任意x, f[x]=min{f[x-2]+1,f[x-5]+1,f[x-7]+1}**



## dp组成部分三:初始条件和边界情况

-  **f[x]=min{f[x-2]+1,f[x-5]+1,f[x-7]+1}**
- 存在两个问题:
  - x-2,x-5,x-7不能小于0
  - 什么时候停止计算?
- 如果不能拼出Y,我们就定义f[Y]=正无穷
  - 例如:f[-1]=f[-2]=...=正无穷
- 所以f[1]=min{f[-1]+1,f[-4]+1,f[-6]+1}=正无穷,表示拼不出来.
- 初始条件:f[0] = 0.
  - 初始条件如何编写?
    - 初始条件是用转移方程无法算出的值.或转移方程计算错误的值.
    - 这时需要我们手动定义它们的值.



## dp组成部分四:计算顺序

- 拼出x所需要的最少硬币数: f[x]=min{f[x-2]+1,f[x-5]+1,f[x-7]+1}
- 初始条件:f[0]=0
- 然后计算f[1],f[2],f[3],....,f[x]
- 计算顺序如何确定?
  - 当我们计算的f[x]时,f[x-2],f[x-5],f[x-7]都已经得到结果了.



- 复杂度:
  - 每一步尝试len(coins)中硬币,一共n步.
  - 与递归算法相比,没有任何重复计算.
  - 时间复杂度:len(coins)*n
  - 递归时间复杂度: 远大于len(coins)*n.

## 编码

```go
package test1

import "math"

func CoinChange(coins []int, amount int) int {
	f := make([]int, amount+1)
	f[0] = 0

	for i := 1; i <= amount; i++ {
		f[i] = math.MaxInt
		//last coin coins[j]
		for j := range coins {
			if i >= coins[j] && f[i-coins[j]] != math.MaxInt {
				f[i] = Min(f[i-coins[j]]+1, f[i])
			}
		}
	}
	if f[amount] == math.MaxInt {
		f[amount] = -1
	}
	return f[amount]
}

```

